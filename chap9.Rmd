---
title: "Chap9"
output: html_document
date: "2023-09-22"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### spatialregによる実例

```{r}
library(spatialreg)
library(spdep)
library(car)
```

```{r}
data(boston)
```

```{r}
boston.c[1:5,]
```

いまから、住宅価格の中央値（修正値）であるところのCMEDVを被説明変数とする分析事例をだす。

これはnb形式で隣接性をまとめたもの。

```{r}
boston.soi
```

### 推定方法一覧

| なまえ                   | 式                       | 備考                      |
|--------------------------|--------------------------|---------------------------|
| 空間ラグモデル           | `spatialreg::lagsarlm`   |                           |
| 空間エラーモデル         | `spatialreg::errorsarlm` |                           |
| 空間ダービンモデル       | `spatialreg::lagsarlm`   | `type="mixed"` とする。   |
| 空間ダービンエラーモデル | `spatialreg::errorsarlm` | `etype="emixed"` とする。 |
| SLXモデル                | `spatialreg::lmSLX`      |                           |
| SARARモデル              | `spatialreg::sacsarlm`   |                           |


関数名はみたところ`***sarlm`のようである。
`lm`は言わずと知れた`lm`のことであろう。
そこにSARを示す`sar`があると思われる。

### 下準備

なんにせよまず、重み行列である
```{r}
w <- nb2listw(boston.soi)
```

そして回帰式を考えてみよう
CMEDVは、CRIMとRMの二乗とLSTATの対数値であらわされる、と考える。
y = ax1 + bx2 + cx3 + d 
みたいな。
これは次のようなコードで表現する。

```{r}
formula <- log(boston.c$CMEDV) ~ boston.c$CRIM + I(boston.c$RM^2) + log(boston.c$LSTAT)
```

この回帰モデルを一度、`lm`関数で推定する。さらにその結果を`summary`関数で出力し解釈してみる
```{r}
lmod <- lm(formula, data = boston.c)
summary(lmod)
```

出力について、
Estimate：推定された回帰係数
y = ax1 + bx2 + cx3 + d　で考えると、下みたいになる。
a = -0.012073
b =  0.008684
c = -0.405917
d =  3.693343
横のstd.Error は標準偏差、t value はt値、Prはp値である。
で、どれも、p値は小さいので有意であると示されている。
またR自乗値とかも 0.75 くらいであり、ちゃんと説明できる感がある。

そして、説明変数間の多重共線性も見てみよう。
`car`パッケージをつかって次のように評価できる。
```{r}
car::vif(lmod)
```

一般に vif >= 10 で、深刻な多重共線性が疑われる。
今回はそんなことはなさげである。めでたしめでたし。

では、ないんですね。線形回帰モデルの残渣に空間相関が存在する場合、誤差項は夢想間である、という仮定が満たされない。
結果、回帰係数の統計的な優位性が適切に票Kされなくなるので。
そこでまず、残差の空間相関の統計的な優位性をモランI統計量で検定する。
`lm.morantest`関数が、そうである。
```{r}
spdep::lm.morantest(lmod, w)
```

Moran I statistic standard deviate がZ値で、これが+-1.96以上だと5%水準で有意な空間相関が残差に存在する、となる。
で、いま、17.454なので、明らかに、空間相関がある、と判定される。
したがってただの線形回帰ではダメで、空間相関を考慮したモデルが必要である。

### モデル選択

おおざっぱに、空間ラグモデルか空間エラーモデルのどちらが適するのか？
これはラグランジュ乗数検定で評価できる。
空間ラグモデルでの帰無仮説は「ρ=0」、空間エラーモデルでの帰無仮説は「λ=0」で、これらの帰無仮説が棄却されなかったならば、通常の線形回帰。
前者のみがあれなら空間ラグ、後者の実があれなら空間エラー。
どちらも採択されたなら、さらに頑健ラグランジュ乗数検定へとうつｒ。
とりまラグランジュ乗数検定を実施してみる。
下のように、 test = c("LMlag", "LMerr") と指定するのがミソである。
```{r}
tree <- spdep::lm.LMtests(lmod, w, test = c("LMlag", "LMerr"))
summary(tree)
```

この結果、どちらも有意であることが判定される。
が、統計量の大きい空間エラーモデルのほうが相対的には支持される、ということがわかる。
一応、頑健ラグランジュ乗数検定も実施しよう。
これは、被説明変数と誤差項に対する両空間相関のうちの一方が存在しない、という条件で他方の優位性を検定しようとするもの。
```{r}
tree2 <- spdep::lm.LMtests(lmod, w, test = c("RLMlag", "RLMerr"))
summary(tree2)
```

結局どちらも支持される結果ではあるし、空間エラーモデルのほうがマシ、というのも変わらない。
ラグランジュ乗数検定でのモデル選択のメリットは、各モデルのパラメータ推定の前に見通しを立てられることである。
当然、各モデルの計算をして、それらの制度比較によってモデル選定、というのも可能である。
ラグランジュ乗数検定が唯一のモデル選択方法ということではない。

### 空間ラグモデル

以下のように出す。
`spatialreg::lagsarlm`
 - 第一引数：モデル式
 - 第二引数：推定に使うデータフレーム
 - 第三引数：重み行列（行基準化したのが普通）
 - 第四引数：特異性の許容度合調整パラメータ、逆行列計算の
```{r}
slm <- spatialreg::lagsarlm(formula, boston.c, listw = w, tol.solve = 1.0e-20)
```

結果をみる
```{r}
summary(slm)
```


### 空間エラーモデル

### 空間ダービンモデル
